var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = AiidaDFTK","category":"page"},{"location":"#AiidaDFTK","page":"Home","title":"AiidaDFTK","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia-side implementation of the Aiida plugin of DFTK. For more information how to setup and use DFTK with Aiida, see the documentation of the python side of the plugin.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Useful information might also be available in the DFTK-specific guides for Installation and Using DFTK on compute clusters.","category":"page"},{"location":"#Functionality","page":"Home","title":"Functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements a run function, which parses a JSON input to trigger a DFTK-based calculation. Results are again dumped in a JSON/HDF5-compatible form and can be easily parsing in downstream scripts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the moment there are no guarantees in the input / output format except that it works in combination with the aiida-dftk plugin. If you wish to use the pipeline implemented by this package in combination with a different downstream driver, please feel free to contact us.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some general (and not necessarily up to date) remarks on the input and output formats are given in Input and Output format.","category":"page"},{"location":"#API-and-supported-methods","page":"Home","title":"API and supported methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [AiidaDFTK]","category":"page"},{"location":"#AiidaDFTK.run-Tuple{}","page":"Home","title":"AiidaDFTK.run","text":"run() -> @NamedTuple{output_files::Vector{String}}\n\n\nRun a DFTK calculation from a json input file. The input file name is expected to be passed as the first argument when calling Julia (i.e. it should be available via ARGS. This function is expected to be called from queuing system jobscripts, for example:\n\njulia --project -e 'using AiidaDFTK; AiidaDFTK.run()' /path/to/input/file.json\n\n\n\n\n\n","category":"method"},{"location":"#AiidaDFTK.run_json-Tuple{AbstractString}","page":"Home","title":"AiidaDFTK.run_json","text":"run_json(\n    filename::AbstractString;\n    extra_output_files\n) -> @NamedTuple{output_files::Vector{String}}\n\n\nRun a DFTK calculation from a json input file. Output is by default written to stdout and stderr. The list of generated output files is returned.\n\n\n\n\n\n","category":"method"},{"location":"input_output/#Input-and-Output-format","page":"Input and Output format","title":"Input and Output format","text":"","category":"section"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"This file gives a quick and dirty overview of the input and files of this package. No guarantees are given that this data is correct or up to date. We only make sure it works well in combination with the aiida-dftk plugin.","category":"page"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"If you wish to use the same IO pipeline in combination with a different package, please feel free to get in touch with us.","category":"page"},{"location":"input_output/#JSON-input","page":"Input and Output format","title":"JSON input","text":"","category":"section"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"We follow the file iron.json as an example. All units are atomic units.","category":"page"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"The dict key periodic_system contains the structure: bounding_box the list of lattice vectors, atoms the individual atoms with their cartesian positions, pseudopotential information and extra keys, such as the initial magnetic moments. This block of data is parsed by AiidaDFTK.build_system.","category":"page"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"The dict keys model_kwargs and basis_kwargs list the keyword arguments to be passed to the DFTK.model_DFT and DFTK.PlaneWaveBasis functions. This data passes through the AiidaDFTK.parse_kwargs function, such that some special processing is available:","category":"page"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"Strings prefixed with : are interpreted as Julia symbols\nDicts with a key $symbol cause a Julia object to be constructed. In the iron example, this is used to specify Gaussian smearing by constructing a Smearing.Gaussian() object.\nThe special strings $basis and $model will be replaced by the results to the calls to DFTK.PlaneWaveBasis and DFTK.model_DFT, respectively.","category":"page"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"For the functionals key (Exchange-correlation functional) all keys supported by model_DFT, (that is the keys of Libxc, are available.","category":"page"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"The dict key scf specifies the SCF options. With the $function key set to self_consistent_field a one-shot SCF is run. The $kwargs list the keyword arguments passed to the DFTK.self_consistent_field function. These keys again pass through AiidaDFTK.parse_kwargs, such that above special processing is available. In the iron.json example this is used to construct a DFTK.ScfConvergenceEnergy object, setting the convergence tolerance to 1e-4 in the energy and to switch the mixing to DFTK.KerkerDosMixing.","category":"page"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"Finally the dict key postscf lists functions to run after the SCF has been converged. This includes","category":"page"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"compute_forces_cart: Computation of Cartesian forces\ncompute_stresses_cart: Computation of Cartesian stresses.","category":"page"},{"location":"input_output/#Output-files","page":"Input and Output format","title":"Output files","text":"","category":"section"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"After the SCF has been run, the DFTK.save_scfres function is used to store the final state in the self_consistent_field.json file and in the JLD2 file specified by the scf/checkpointfile key. The JSON file only contains \"small\" results (energies, eigenvalues etc.) while the JLD2 file contains the density (and if scf/save_Ïˆ is true) also the wavefunction. Since JLD2 is compatible with HDF5 file, the latter file can be read using h5py or similar packages. Both the JSON and JLD2 formats are used from DFTK without modification, so see the documentation of DFTK.save_scfres for more details.","category":"page"},{"location":"input_output/","page":"Input and Output format","title":"Input and Output format","text":"Additionally timings are stored in timings.json and results of post-SCF steps (such as force calculations) in $function.hdf5. I.e. if you run the post-SCF step compute_forces_cart, then the forces are stored in compute_forces_cart.hdf5.","category":"page"}]
}
